#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S3,     sonarSensor,    sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//
//		TYPEDEFS
//
typedef enum task_r {FORAGE, LINE_FOLLOW, AVOID, OBSERVE};
typedef enum avoid_steps_r {BACK, AROUND, REENTER};

//
//		METHOD SIGNATURES
//

bool isBlackish(int value);
bool should_run_line_follow();
bool should_run_avoid();

//
//		GLOBAL VARIABLES
//
int output_forage[2] = {0,0};
int output_line_follow[2] = {0,0};
int output_avoid[2] = {0,0};


int black,white;
float kp = 1 , ki = 0.0001, kd = 50;
//float kp = 1.5 , ki = 0.0001, kd = 100;

//1.7 0     100
//1.2 0.001 50


//
//		FUNCTIONS
//
void calibrate(){


	nxtDisplayCenteredBigTextLine(2,"WHITE");
	do{
		white = SensorValue(lightSensor);
	}while(nNxtButtonPressed != 3);

	Sleep(1000);

	nxtDisplayCenteredBigTextLine(2,"BLACK");
	do{
		black = SensorValue(lightSensor);
	}while(nNxtButtonPressed != 3);

	Sleep(1000);

	nxtDisplayCenteredBigTextLine(2,"START!");
	do{
		Sleep(100);
	}while(nNxtButtonPressed != 3);

	nxtDisplayClearTextLine(2);
}


//
//			DECIDE
//
task_r decide() {

	nxtDisplayClearTextLine(1);
	nxtDisplayClearTextLine(2);
	nxtDisplayClearTextLine(3);

	task_r cmd = FORAGE;
	nxtDisplayCenteredBigTextLine(1,"FORAGE");


	if(should_run_line_follow()){
		cmd = LINE_FOLLOW;
		nxtDisplayCenteredBigTextLine(1,"LN FOLLOW");
	}

	if(should_run_avoid()){
		//Checks Sonar Sensor
		cmd = AVOID;
		nxtDisplayCenteredBigTextLine(1,"AVOID");
	}

	if(false){
		//Checks if we need to observe
		cmd = OBSERVE;
		nxtDisplayCenteredBigTextLine(1,"OBSERVE");
	}

	return cmd;

}


//
//			FORAGE
//

task forage_task(){
	output_forage[0] = 30;
	output_forage[1] = 15;
}


//
//		FOLLOW LINE
//

task follow_line_task(){

	//Initialises timer that checks how long we`ve been out of track
	ClearTimer(T1);

	while(true){
		float midpoint = (white-black)/2 + black;

		static float integral;
		float derivative=0;

		static float previousError;
		float currentError = 0;
		float currentValue = 0;

		float output;

		currentValue = SensorValue(lightSensor);
		currentError = midpoint - currentValue;
		integral = 2/3 * integral + currentError;
		derivative = currentError - previousError ;

		output = kp * currentError + ki * integral + kd * derivative;

		output_line_follow[0] = 20 + output;
		output_line_follow[1] = 20 - output;

		previousError = currentError;

		//If we are on track, resets the timer, that lets us know that we`ve been
		//recently on-track and should continue line-following
		if(isBlackish(currentValue)){
			ClearTimer(T1);
		}
		//TODO re-calibrate black/white here? (calc a mean between stored&current values?)
	}
}

bool isBlackish(int value){
	//If value is within 10 units of what we think is black, return true.
	return (value > black - 10 && value < black + 10);
}

bool should_run_line_follow(){
	//We should run line follow if we are on track (the timer hasn`t counted much)
	return time1[T1] < 2000;
}


//
//			AVOID
//
task avoid_task(){

	static avoid_steps_r status;

	switch (status){
		case BACK:
			status = AROUND;
		break;

		case AROUND:

			status = REENTER
		break;

		case REENTER:


		break;
	}

}

bool should_run_avoid(){
	int value = SensorValue(sonarSensor);
	return value > 0 && value < 15;
}

//
//			OBSERVE
//
task observe_task(){
}


//
//			MAIN
//
task main()
{

	calibrate();

	//Start tasks
	StartTask(forage_task);
	StartTask(follow_line_task);
	StartTask(avoid_task);
	StartTask(observe_task);


	//Loops over their output and use it to control what actually happens to the robot.
	while(true){

		switch(decide()){
			case FORAGE:
						motor[motorC] = output_forage[0];
						motor[motorA] = output_forage[1];
				break;

			case LINE_FOLLOW:
						motor[motorC] = output_line_follow[0];
						motor[motorA] = output_line_follow[1];
				break;

			case AVOID:
						motor[motorC] = output_avoid[0];
						motor[motorA] = output_avoid[1];
				break;

			case OBSERVE:
				break;
		}

	}

}
