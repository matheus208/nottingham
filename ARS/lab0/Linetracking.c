#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S3,     sonarSensor,    sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


typedef enum task_r {FORAGE, LINE_FOLLOW, AVOID, OBSERVE};


int output_forage[2] = {0,0};
int output_line_follow[2] = {0,0                      bbbbbbbbbbbbbbbb};


int black,white;
float kp = 0.8 , ki = 0, kd = 0.8;
//float kp = 1.5 , ki = 0.0001, kd = 100;

//1.7 0     100
//1.2 0.001 50

void calibrate(){

	//TODO calibrate what black and white actually are
	black = 32;
	white = 66;

}


//
//			DECIDE
//
task_r decide() {

	task_r cmd = FORAGE;

	if(SensorValue(lightSensor) < black + 20){
		cmd = LINE_FOLLOW;
	} else if(false){
		//Checks Sonar Sensor
		cmd = AVOID;
	} else if(false){
		//Checks if we need to observe
		cmd = OBSERVE;
	}

	return cmd;

}


//
//			FORAGE
//

task forage_task(){
	output_forage[0] = 40;
	output_forage[1] = 20;
}


//
//		FOLLOW LINE
//

task follow_line_task(){

	float midpoint = (white-black)/2 + black;

	static float integral;
	float derivative=0;

	static float previousError;
	float currentError = 0;
	float currentValue = 0;

	float output;

	currentValue = SensorValue(lightSensor);
	currentError = midpoint - currentValue;
	integral = integral + currentError;
	derivative = currentError - previousError ;

	output = kp * currentError + ki * integral + kd * derivative;

	output_line_follow[0] = 40 + output;
	output_line_follow[1] = 40 - output;

	previousError = currentError;
}


//
//			AVOID
//
task avoid_task(){
}


//
//			OBSERVE
//
task observe_task(){
}


//
//			MAIN
//
task main()
{

	calibrate();


	while(1){

		//Start tasks
		StartTask(forage_task);
		StartTask(follow_line_task);
		StartTask(avoid_task);
		StartTask(observe_task);


		//Loops over their output and use it to control what actually happens to the robot.
		while(true){

			switch(decide()){
				case FORAGE:
							motor[motorC] = output_forage[0];
							motor[motorA] = output_forage[1];
					break;

				case LINE_FOLLOW:
							motor[motorC] = output_line_follow[0];
							motor[motorA] = output_line_follow[1];
					break;

				case AVOID:
					break;

				case OBSERVE:
					break;
			}

		}

	}

}
